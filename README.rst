# Template for pytask plugins

This template has been generated by comparing the R and Stata plugins. It is thus based on the assumption that anything which is common between those two plugins is likely to be the same in the new plugin as well.

Usage:
- Download the source code
- Rename the folder `src/pytask_xxxxx` to `src/pytask_[your plugin's identifier]`
- Open this entire source code in an editor.
- Do project wide search (S) and replace for:

  - **S**: YYYYY, **R**: [Your language's verbose name, e.g. R, Stata, Julia]
  - **S**: ZZZZZ, **R**: [The command to start your program, e.g. RScript] *(if not common across platforms or more complicated, see the Stata plugin for more involved handling)*
  - **S**: pytask-xxxxx, **R**: pytask-[your plugin's identifier]
  - **S**: pytask_xxxxx, **R**: pytask_[your plugin's identifier]
  - **S**: xxxxx, **R** on a case-by-case basis. This will often be your plugin's identifier, but can also be the extension of scripts in your language (e.g., `r`, `do`, `jl`) or other things.

- Try out
- Likely the first necessary adjustments will be to the code in collect.py
- For sure, later adjustments will be necessary for
  - the code snippets in the tests and README.rst
  - the author name and e-mail in `setup.cfg`
- Please let us know any things you think are worth noting!

------

pytask-julia
============

.. image:: https://img.shields.io/pypi/pyversions/pytask-julia
    :alt: PyPI - Python Version
    :target: https://pypi.org/project/pytask-julia

.. image:: https://img.shields.io/conda/vn/conda-forge/pytask-julia.svg
    :target: https://anaconda.org/conda-forge/pytask-julia

.. image:: https://img.shields.io/conda/pn/conda-forge/pytask-julia.svg
    :target: https://anaconda.org/conda-forge/pytask-julia

.. image:: https://img.shields.io/pypi/l/pytask-julia
    :alt: PyPI - License
    :target: https://pypi.org/project/pytask-julia

.. image:: https://img.shields.io/github/workflow/status/hmgaudecker/pytask-julia/main/main
    :target: https://github.com/hmgaudecker/pytask-julia/actions?query=branch%3Amain

.. image:: https://readthedocs.org/projects/pytask-julia/badge/?version=latest
    :target: https://pytask-julia.readthedocs.io/en/latest/?badge=latest
    :alt: Documentation Status

.. image:: https://codecov.io/gh/hmgaudecker/pytask-julia/branch/main/graph/badge.svg
    :target: https://codecov.io/gh/hmgaudecker/pytask-julia

.. image:: https://results.pre-commit.ci/badge/github/hmgaudecker/pytask-julia/main.svg
    :target: https://results.pre-commit.ci/latest/github/hmgaudecker/pytask-julia/main
    :alt: pre-commit.ci status

.. image:: https://img.shields.io/badge/code%20style-black-000000.svg
    :target: https://github.com/ambv/black


Installation
------------

pytask-julia is available on `PyPI <https://pypi.org/project/pytask-julia>`_ and `Anaconda.org <https://anaconda.org/conda-forge/pytask-julia>`_. Install it with

.. code-block:: console

    $ pip install pytask-julia

    # or

    $ conda install -c conda-forge pytask-julia

You also need to have YYYYY installed and ``ZZZZZ`` on your command line. Test it by
typing the following on the command line

.. code-block:: console

    $ ZZZZZ --help

If an error is shown instead of a help page, you can install YYYYY ....


Usage
-----

Similarly to normal task functions which execute Python code, you define tasks to
execute scripts written in YYYYY with Python functions. The difference is that the
function body does not contain any logic, but the decorator tells pytask how to handle
the task.

Here is an example where you want to run ``script.xxxxx``.

.. code-block:: python

    import pytask


    @pytask.mark.xxxxx
    @pytask.mark.depends_on("script.xxxxxx")
    @pytask.mark.produces("out.csv")
    def task_run_xxxxx_script():
        pass

Note that, you need to apply the ``@pytask.mark.xxxxx`` marker so that pytask-xxxxx handles the
task.

If you are wondering why the function body is empty, know that pytask-xxxxx replaces the
body with a predefined internal function. See the section on implementation details for
more information.


Multiple dependencies and products
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What happens if a task has more dependencies? Using a list, the YYYYY script which should be
executed must be found in the first position of the list.

.. code-block:: python

    @pytask.mark.xxxxx
    @pytask.mark.depends_on(["script.xxxxx", "input.csv"])
    @pytask.mark.produces("out.csv")
    def task_run_xxxxx_script():
        pass

If you use a dictionary to pass dependencies to the task, pytask-xxxxx will, first, look
for a ``"source"`` key in the dictionary and, secondly, under the key ``0``.

.. code-block:: python

    @pytask.mark.xxxxx
    @pytask.mark.depends_on({"source": "script.xxxxx", "input": "input.csv"})
    def task_run_xxxxx_script():
        pass


    # or


    @pytask.mark.xxxxx
    @pytask.mark.depends_on({0: "script.xxxxx", "input": "input.csv"})
    def task_run_xxxxx_script():
        pass


    # or two decorators for the function, if you do not assign a name to the input.


    @pytask.mark.xxxxx
    @pytask.mark.depends_on({"source": "script.xxxxx"})
    @pytask.mark.depends_on("input.csv")
    def task_run_xxxxx_script():
        pass


Command Line Arguments
~~~~~~~~~~~~~~~~~~~~~~

The decorator can be used to pass command line arguments to ``ZZZZZ``. See the
following example.

.. code-block:: python

    @pytask.mark.xxxxx("value")
    @pytask.mark.depends_on("script.xxxxx")
    @pytask.mark.produces("out.csv")
    def task_run_xxxxx_script():
        pass

And in your ``script.xxxxx``, you can intercept the value with

.. code-block:: YYYYY

    FIXME FOR YOUR LANGUAGE
    args <- commandArgs(trailingOnly=TRUE)
    arg <- args[1]  # holds ``"value"``


Parametrization
~~~~~~~~~~~~~~~

You can also parametrize the execution of scripts, meaning executing multiple YYYYY scripts
as well as passing different command line arguments to the same YYYYY script.

The following task executes two YYYYY scripts which produce different outputs.

.. code-block:: python

    from src.config import BLD, SRC


    @pytask.mark.xxxxx
    @pytask.mark.parametrize(
        "depends_on, produces",
        [(SRC / "script_1.xxxxx", BLD / "1.csv"), (SRC / "script_2.xxxxx", BLD / "2.csv")],
    )
    def task_execute_xxxxx_script():
        pass

And the R script includes something like

.. code-block:: r

    args <- commandArgs(trailingOnly=TRUE)
    produces <- args[1]  # holds the path

If you want to pass different command line arguments to the same YYYYY script, you have to
include the ``@pytask.mark.xxxxx`` decorator in the parametrization just like with
``@pytask.mark.depends_on`` and ``@pytask.mark.produces``.

.. code-block:: python

    @pytask.mark.depends_on("script.xxxxx")
    @pytask.mark.parametrize(
        "produces, xxxxx",
        [(BLD / "output_1.csv", "1"), (BLD / "output_2.csv", "2")],
    )
    def task_execute_xxxxx_script():
        pass


Configuration
-------------

If you want to change the name of the key which identifies the YYYYY script, change the
following default configuration in your pytask configuration file.

.. code-block:: ini

    xxxxx_source_key = source


Implementation Details
----------------------

The plugin is a convenient wrapper around

.. code-block:: python

    import subprocess

    subprocess.run(["ZZZZZ", "script.xxxxx"], check=True)

to which you can always resort to when the plugin does not deliver functionality you
need.

It is not possible to enter a post-mortem debugger when an error happens in the YYYYY script
or enter the debugger when starting the script. If there exists a solution for that,
hints as well as contributions are highly appreciated.


Changes
-------

Consult the `release notes <CHANGES.rst>`_ to find out about what is new.
